<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Sweet Sugar</title><description>Thoughts, stories and ideas.</description><link>http://localhost:2368/</link><generator>Ghost 0.7</generator><lastBuildDate>Wed, 06 Apr 2016 14:43:34 GMT</lastBuildDate><atom:link href="http://localhost:2368/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>浏览器缓存碎碎念</title><description>&lt;p&gt;浏览器缓存技术是提升前端性能一个非常重要的手段。在当前浏览器各方面性能都大幅提升的情况下，前端性能的瓶颈更多的集中在资源请求方面。&lt;/p&gt;

&lt;h2 id=""&gt;原理&lt;/h2&gt;

&lt;p&gt;说浏览器缓存，其实就是在说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器实现缓存的机制&lt;/li&gt;
&lt;li&gt;HTTP通讯协议定义的关于缓存的字段内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先让我们回顾下，当我们在浏览器的地址栏输入URL之后发生哪些过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;DNS服务器&lt;/code&gt;解析域名，找到对应服务器的&lt;code&gt;IP地址&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;和服务器建立&lt;code&gt;TCP连接&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;TCP连接&lt;/code&gt;进行HTTP的&lt;code&gt;Req/Res&lt;/code&gt;，服务器会根据HTTP请求到&lt;code&gt;数据服务器&lt;/code&gt;取出相应的资源，并返回给前端；  &lt;/li&gt;
&lt;li&gt;浏览器获取HTML文档，并开始&lt;code&gt;解析&lt;/code&gt;；  &lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;link&lt;/code&gt;标签，加载&lt;code&gt;href&lt;/code&gt;指向的地址，并解析&lt;code&gt;css&lt;/code&gt;，遇到带有&lt;code&gt;src&lt;/code&gt;属性，且没有声明&lt;code&gt;async或defer&lt;/code&gt;属性的&lt;code&gt;script&lt;/code&gt;标签时，同步加载远程&lt;code&gt;js脚本&lt;/code&gt;，同步解析js脚本，同步执行js脚本，浏览器的&lt;code&gt;GUI渲染&lt;/code&gt;&lt;/li&gt;&lt;/ol&gt;</description><link>http://localhost:2368/liu-lan-qi-huan-cun-sui-sui-nian/</link><guid isPermaLink="false">e6cfddef-49b3-40a7-b78e-7ebccc4d4db3</guid><category>浏览器特性</category><dc:creator>XRene</dc:creator><pubDate>Wed, 06 Apr 2016 14:08:00 GMT</pubDate><content:encoded>&lt;p&gt;浏览器缓存技术是提升前端性能一个非常重要的手段。在当前浏览器各方面性能都大幅提升的情况下，前端性能的瓶颈更多的集中在资源请求方面。&lt;/p&gt;

&lt;h2 id=""&gt;原理&lt;/h2&gt;

&lt;p&gt;说浏览器缓存，其实就是在说：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;浏览器实现缓存的机制&lt;/li&gt;
&lt;li&gt;HTTP通讯协议定义的关于缓存的字段内容&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;先让我们回顾下，当我们在浏览器的地址栏输入URL之后发生哪些过程：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;DNS服务器&lt;/code&gt;解析域名，找到对应服务器的&lt;code&gt;IP地址&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;和服务器建立&lt;code&gt;TCP连接&lt;/code&gt;;  &lt;/li&gt;
&lt;li&gt;基于&lt;code&gt;TCP连接&lt;/code&gt;进行HTTP的&lt;code&gt;Req/Res&lt;/code&gt;，服务器会根据HTTP请求到&lt;code&gt;数据服务器&lt;/code&gt;取出相应的资源，并返回给前端；  &lt;/li&gt;
&lt;li&gt;浏览器获取HTML文档，并开始&lt;code&gt;解析&lt;/code&gt;；  &lt;/li&gt;
&lt;li&gt;遇到&lt;code&gt;link&lt;/code&gt;标签，加载&lt;code&gt;href&lt;/code&gt;指向的地址，并解析&lt;code&gt;css&lt;/code&gt;，遇到带有&lt;code&gt;src&lt;/code&gt;属性，且没有声明&lt;code&gt;async或defer&lt;/code&gt;属性的&lt;code&gt;script&lt;/code&gt;标签时，同步加载远程&lt;code&gt;js脚本&lt;/code&gt;，同步解析js脚本，同步执行js脚本，浏览器的&lt;code&gt;GUI渲染&lt;/code&gt;过程处于挂起状态。当js执行完毕后，继续后面的HTML解析的工作；  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;DOM树&lt;/code&gt;构建完毕，&lt;code&gt;CSS Rules&lt;/code&gt;解析完毕；  &lt;/li&gt;
&lt;li&gt;由&lt;code&gt;DOM树&lt;/code&gt;和&lt;code&gt;CSS Rules&lt;/code&gt;一起构建&lt;code&gt;Render树&lt;/code&gt;。和&lt;code&gt;DOM树&lt;/code&gt;不一样的地方在于&lt;code&gt;Render树&lt;/code&gt;是带有DOM样式的，&lt;code&gt;伪元素&lt;/code&gt;不会在&lt;code&gt;DOM树&lt;/code&gt;中出现，而会在&lt;code&gt;Render树&lt;/code&gt;中出现。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Render树&lt;/code&gt;构建完毕后开始&lt;code&gt;repaint&lt;/code&gt;和&lt;code&gt;reflow&lt;/code&gt;过程，即&lt;code&gt;渲染&lt;/code&gt;。最后将页面呈现给用户。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在这些过程当中：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;过程1：远程服务器可能是&lt;code&gt;代理服务器&lt;/code&gt;，代理服务器可进行缓存匹配，可将缓存的资源直接返回给前端，降低对于源服务器的压力，同时还能做均衡负载；&lt;/li&gt;
&lt;li&gt;过程3：&lt;code&gt;数据服务器&lt;/code&gt;可以进行&lt;code&gt;memcached&lt;/code&gt;，进行数据库层面的缓存，可将上一次的查询结果缓存到内存当中，下次再查询相同的数据时，直接从内容从取出数据；&lt;/li&gt;
&lt;li&gt;过程5：可以利用&lt;code&gt;浏览器缓存&lt;/code&gt;。这也是本文所讲的主要内容。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当我访问 SegmentFault 的个人主页时：&lt;/p&gt;

&lt;p&gt;&lt;img src="https://segmentfault.com/img/bVuBrE" alt="图片描述"&gt;&lt;/p&gt;

&lt;p&gt;在浏览器&lt;strong&gt;首次&lt;/strong&gt;加载并解析HTML文档时，会维护一个资源的&lt;code&gt;缓存池&lt;/code&gt;，&lt;code&gt;缓存池&lt;/code&gt;里存放了加载的包括css,js,图片,字体等文件，&lt;code&gt;URL&lt;/code&gt;是这些资源的唯一标识。浏览器会根据&lt;code&gt;HTTP响应字段&lt;/code&gt;来决定这些资源是否能缓存以及缓存的时间等：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Expires&lt;/code&gt;字段设置了资源过期的时间。  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cache-control&lt;/code&gt;字段的内容较多，例如no-cache会决定资源不会缓存;max-age指客户机可以接收生存期不大于指定时间（以秒为单位）的响应。具体的内容(图)  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Etag&lt;/code&gt;：资源的唯一标识符  &lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last-Modified&lt;/code&gt;: 资源最后一次修改的时间&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果将页面&lt;strong&gt;刷新&lt;/strong&gt;，此时加载同一份HTML文件，同样遇到外联的css，js，图片和字体等文件。此时浏览器首先会从缓存池中寻找，寻找的标记为资源的URL地址。&lt;/p&gt;

&lt;p&gt;&lt;img src="https://segmentfault.com/img/bVuBse" alt="图片描述"&gt;&lt;/p&gt;

&lt;p&gt;如果缓存池中有对应的资源，通过查询&lt;code&gt;Expires字段&lt;/code&gt;和&lt;code&gt;Cache-control字段&lt;/code&gt;的值，如果没有过期，那么会从缓存池中获取资源，不会进行HTTP请求。&lt;/p&gt;

&lt;p&gt;若资源过期，则会进行HTTP请求，此时浏览器会检查缓存池中资源是否具有&lt;code&gt;Etag&lt;/code&gt;和&lt;code&gt;Last-modified&lt;/code&gt;.如果有&lt;code&gt;Etag&lt;/code&gt;字段(资源的唯一标识符，只要发生修改，其值都会发生改变)的内容，那么HTTP请求中会带上&lt;code&gt;If-none-match&lt;/code&gt;字段，其值为&lt;code&gt;Etag&lt;/code&gt;字段的内容，如果有&lt;code&gt;Last-Modified&lt;/code&gt;字段(最后一次修改的时间)，那么HTTP请求会带上&lt;code&gt;If-Modified-Since&lt;/code&gt;字段，其值为&lt;code&gt;Last-modified&lt;/code&gt;字段的内容。服务器根据HTTP请求去匹配&lt;code&gt;If-none-match&lt;/code&gt;和&lt;code&gt;If-Modified-Since&lt;/code&gt;的内容。&lt;/p&gt;

&lt;p&gt;当&lt;code&gt;If-none-match&lt;/code&gt;的内容匹配不成功时，服务器会返回状态码为&lt;code&gt;200 success&lt;/code&gt;的响应及所有的资源内容，并设置新的和缓存相关的字段内容，若匹配成功返回&lt;code&gt;304 Not Modify&lt;/code&gt;响应状态，但是不会返回资源内容。此时浏览器仍然是从资源池中获取资源。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;的处理方式和&lt;code&gt;If-none-match&lt;/code&gt;相同。&lt;/p&gt;

&lt;p&gt;当以上2个字段在HTTP请求中都存在时，会优先匹配&lt;code&gt;If-None-Match&lt;/code&gt;的内容，只有&lt;strong&gt;相同的情况下才会去匹配&lt;/strong&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;的内容，来绝对是返回200还是304。&lt;/p&gt;

&lt;h2 id=""&gt;总结&lt;/h2&gt;

&lt;p&gt;页面首次加载&lt;/p&gt;

&lt;p&gt;&lt;img src="https://segmentfault.com/img/bVuBva" alt="初次加载"&gt;&lt;/p&gt;

&lt;p&gt;页面刷新&lt;/p&gt;

&lt;p&gt;&lt;img src="https://segmentfault.com/img/bVuBBN" alt="页面刷新"&gt;&lt;/p&gt;

&lt;h2 id=""&gt;实践&lt;/h2&gt;

&lt;p&gt;之前在实习的过程中，对于浏览器缓存所做的工作之一就是每次在发版前通过gulp给资源打上版本号，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class="language-javascript"&gt;"/css/style.css" =&amp;gt; "/dist/css/style.css?v=1d87bebe"；
"/js/script1.js" =&amp;gt; "/dist/script1.js?v=61e0be79"；
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样再去首页去加载这些资源的时候，因为在资源池里找不到对应的URL，因此会发送HTTP请求，从服务器端获取最新的资源。 具体实践过程请自行&lt;code&gt;google&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=""&gt;参考资料&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.cnblogs.com/skynet/archive/2012/11/28/2792503.html"&gt;浏览器缓存机制&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;《webkit技术内幕》  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.mnot.net/cache_docs/"&gt;HTTP Cache&lt;/a&gt;  &lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/speed/docs/insights/LeverageBrowserCaching#header_2"&gt;Google Develop Http Caching &lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>